#pragma config(Sensor, in1,    infrasenseshort, sensorReflection)
#pragma config(Sensor, in2,    infrasenselong, sensorReflection)
#pragma config(Sensor, in5,    limittop,       sensorTouch)
#pragma config(Sensor, in6,    bumpleft,       sensorTouch)
#pragma config(Sensor, in8,    stopthearm,     sensorTouch)
#pragma config(Sensor, in9,    centrefrontpush, sensorTouch)
#pragma config(Sensor, in10,   encoderleft,    sensorQuadEncoder, int3)
#pragma config(Sensor, in11,   encoderright,   sensorQuadEncoder, int4)
#pragma config(Sensor, in12,   leftbackpush,   sensorTouch)
#pragma config(Sensor, in13,   armbutton,      sensorTouch)
#pragma config(Sensor, in15,   backpush,       sensorTouch)
#pragma config(Sensor, in16,    bumpright,      sensorTouch)
#pragma config(Motor,  port1,           motorleft,     tmotorVex269, openLoop)
#pragma config(Motor,  port2,           motorright,    tmotorVex269, openLoop)
#pragma config(Motor,  port4,           shoulder,      tmotorVex269, openLoop)
#pragma config(Motor,  port5,           elbow,         tmotorVex269, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//All motor values for motorright must be used as negative, as motorright is backwards relative to motorleft
bool bumpleft_pushed; //flag to store left bumper input
bool bumpright_pushed; //flag to store right bumper input
bool armbutton_pushed; //flag to store home position input from button on arm
bool limit_pushed; //flag to store input from limit on the top
bool armstop_pushed; //flag to store end position of arm
bool backpush_pushed; //flag to store input from bumper on back
bool leftbackpush_pushed; //flag to store input from bumper on left side, near back
bool centrefrontpush_pushed; //flag to store input from central front bumper
int turningvalue = 263; //the value encoderright reads after a 90 degree turn
int meterdistance = -980; //the value encoderleft reads after travelling one metre
int backupdistance = 69; //the distance we have decided to back up after hitting a wall with front sensors
int goforwardistance = -69; ////the distance we have decided to go forward after hitting a wall with back sensors
int fullturnvalue = 1152; //the value encoderright reads after a 360 degree turn
int fullspeed = 75; //motor speed for moving forward/backward
int basencodervalue = 0; //reset value for the encoders
int turningspeed = 100; //speed we usually use for turning
int motorstop = 0; //stop value for motors
int sensorturn = 65; //turning speed while scanning
int shouldermove = 75; //motor speed of shoulder for all motions
int elbowreturn = 35;	//motor speed of elbow while returning
int elbowextend = 45; //motor speed of elbow while extending
int neutralizerange = 400; //sensor value of infrasenseshort when in neutralization range, to be adjusted before run
int neutralizelongrange = 900;
int neutralize_SUCCESS = 1; //return value of neutralizecheck() when it has neutralized
int neutralize_FAILURE = 0; //return value of neutralizecheck() when it has not neutralized
int scan_SUCCESS = 1; //return value of all scan functions if the scan was not interrupted by a bumpercheck() action
int scan_FAILURE = 0; //return value of all scan functions if the scan was interrupted by a bumpercheck() action
//int neutralizeminimum = 900; //minimum range of infrasense short for neutralization, to be adjusted before run

/* monitorInput()
*
*  Used to flag button inputs
*       - this avoids errors caused by program recognizing input, taking action, and
*         reading input again before button is released
*/
void monitorInput()
{
	if(SensorValue(centrefrontpush) & !centrefrontpush_pushed){
		centrefrontpush_pushed = true;
	}
	if(SensorValue(leftbackpush) & !leftbackpush_pushed){
		leftbackpush_pushed = true;
	}
	if(SensorValue(backpush) & !backpush_pushed){
		backpush_pushed = true;
	}
  if(SensorValue(limittop) & !limit_pushed){
    limit_pushed = true;
  }

  if(SensorValue(bumpleft) & !bumpleft_pushed){
  	bumpleft_pushed = true;
  }

  if(SensorValue(bumpright) & !bumpright_pushed){
  	bumpright_pushed = true;
  }

  if(!SensorValue(armbutton) & !armbutton_pushed){
  	armbutton_pushed = true;
  }
  if(SensorValue(stopthearm) & !armstop_pushed){
  	armstop_pushed = true;
  }
}

/* 	This is a prototype initialization of the [button]action() family, as they need to be called in bumpercheck()...
*		and they need to call bumpercheck() themselves.
*		Further details on these functions can be found on line 442 where they described in detail.
*/

void centrefrontpushaction();

void bumpleftaction();

void bumprightaction();

void leftbackpushaction();

void backpushaction();

/* bumpercheck()
* 		This function should always be used as part of a while loop whenever the robot is in motion.
*			This function uses monitorInput() to check the inputs of all the outside bumpers, then calls the relevant function to deal with it.
*			This function will reset your bumper flags when called. Make sure you're not using them for anything else.
*/
int bumpercheck(){
	centrefrontpush_pushed = false;
	leftbackpush_pushed = false;
	backpush_pushed = false;
	bumpleft_pushed = false;
	bumpright_pushed = false;
	monitorInput();
	if(centrefrontpush_pushed){
		centrefrontpushaction();
		centrefrontpush_pushed = false;
		return 1;
	}
	if(leftbackpush_pushed){
		leftbackpushaction();
		leftbackpush_pushed = false;
		return 1;
	}
	if(backpush_pushed){
		backpushaction();
		backpush_pushed = false;
		return 1;
	}
	if(bumpleft_pushed){
		bumpleftaction();
		bumpleft_pushed = false;
		return 1;
	}
	if(bumpright_pushed){
		bumprightaction();
		bumpright_pushed = false;
		return 1;
	}
	return 0;
}

/* encoderreset()
*		This function simply resets the values of the left and right encoders. It is not used in all functions because of stack limitations.
*/
void encoderreset(){
	SensorValue[encoderleft] = basencodervalue;
	SensorValue[encoderright] = basencodervalue;
}

/* straightcheck()
*			This function is supposed to be called as part of a while loop.
*			Reset the sensor values of the encoders before you start calling this function in a loop.
*			It tells the motors to move forward.
*			The relative speeds of the motors (slowing one down) based on the difference between the encoder values.
*			This adjusts the motors to make sure they go in a straight line.
*/
void straightcheck(){
	motor[motorleft] = fullspeed;
	motor[motorright] = -fullspeed;
	if(SensorValue[encoderleft] < SensorValue[encoderright]){
		motor[motorleft] = (fullspeed + (SensorValue[encoderright] - SensorValue[encoderleft]));
	}
	if(SensorValue[encoderright] < SensorValue[encoderleft]){
		motor[motorright] = (-fullspeed - (SensorValue[encoderleft] - SensorValue[encoderright]));
	}
}

/* straightcheckback()
* 		This function is identical to straightcheck() except it's for going backwards. It still goes straight.
*/
void straightcheckback(){
	motor[motorleft] = -fullspeed;
	motor[motorright] = fullspeed;
	if(SensorValue[encoderleft] < SensorValue[encoderright]){
		motor[motorleft] = (-fullspeed - (SensorValue[encoderright] - SensorValue[encoderleft]));
	}
	if(SensorValue[encoderright] < SensorValue[encoderleft]){
		motor[motorright] = (fullspeed + (SensorValue[encoderleft] - SensorValue[encoderright]));
	}
}

/* turnright90()
*			This function resets your encoder readings, so make sure you don't need them later.
*			This function turns right 90 degrees.
*			The control stays in the function for the duration of the turn, so you can't do anything else while it's turning.
*/
void turnright90(){
	motor[motorleft] = motorstop;
	motor[motorright] = motorstop;
	SensorValue[encoderleft] = basencodervalue;
	SensorValue[encoderright] = basencodervalue;
	while (SensorValue[encoderright] < turningvalue){
		motor[motorleft] = turningspeed;
		motor[motorright] = turningspeed;
		/*int bumpaction = bumpercheck();
		if(bumpaction == 1){
			return;
		}*/
	}
	motor[motorleft] = motorstop;
	motor[motorright] = motorstop;
}

/*	backupturn()
*			This function is supposed to be called by itself. It resets your encoder readings, so make sure you don't need them later.
*			This function tells the robot to wait, back up for "backupdistance", using straightcheckback to make sure you go straight.
*			Then it calls turnright90() to turn 90 degrees.
*			The control stays in the function for the duration of the movement, so you can't do anything else while it's moving.
*/
void backupturn(){
	SensorValue[encoderleft] = basencodervalue;
	SensorValue[encoderright] = basencodervalue;
	wait10Msec(25);
	while(SensorValue[encoderleft] < backupdistance){
		straightcheckback();
		int bumpaction = bumpercheck();
		if(bumpaction == 1){
			return;
		}
	}
	motor[motorleft] = motorstop;
	motor[motorright] = motorstop;
	wait10Msec(25);
	turnright90();
}

/*	fullturnscan()
*			This function resets your encoderright value to zero. Make sure you don't need it later.
*			This function causes the robot to turn a full circle while scanning for infrared inputs from infrasenselong.
*			If infrasenselong sees an infrared input that is greater than any previous value, then...
*				It stores it in currvalue and stores the current encoderright value in rotationplace.
*			After it's completed the full turn, it rotates in the opposite direction until it finds the encoder value in rotationplace.
*			This function is inaccurate; it won't turn precisely to the source because there is slop in the wheels while turning.
*			This function should be used with panandscan(), as that can find the source accurately if it's within its panning radius.
*			The control stays in the function for the duration of the search, so you can't do anything other than use bumpercheck() while it's looking.
*			This function ends and returns scan_FAILURE if it was interrupted by a bumpercheck() action, or scan_SUCCESS if it wasn't.
*/
int fullturnscan(){
	int currvalue = 0;
	int rotationplace = 0;
	SensorValue[encoderright] = basencodervalue;
	while(SensorValue[encoderright] < fullturnvalue){
		motor[motorleft] = sensorturn;
		motor[motorright] = sensorturn;
		if(SensorValue[infrasenselong] > currvalue){
			currvalue = SensorValue[infrasenselong];
			rotationplace = SensorValue[encoderright];
		}
		int bumpaction = bumpercheck();
		if(bumpaction == 1){
			return scan_FAILURE;
		}
	}
	motor[motorleft] = motorstop;
	motor[motorright] = motorstop;
	while(SensorValue[encoderright] > (rotationplace + 30)){
		motor[motorleft] = -sensorturn;
		motor[motorright] = -sensorturn;
		int bumpaction = bumpercheck();
		if(bumpaction == 1){
			return scan_FAILURE;
		}
	}
	motor[motorleft] = motorstop;
	motor[motorright] = motorstop;
	return scan_SUCCESS;
}

/* panandscan()
*			This function is effectively identical to fullturnscan() above, except...
*				Instead of making a full turn, panandscan() just turns a small distance to each side.
*			This function is more accurate than fullturnscan because its smaller motion means that there's less slop in the wheels.
*			This function is usually accurate to within a few degrees.
*			The control stays in the function for the duration of the search, so you can't do anything other than use bumpercheck() while it's looking.
*			This function ends and returns scan_FAILURE if it was interrupted by a bumpercheck() action, or scan_SUCCESS if it wasn't.
*/
int panandscan(){
	int currvalue = motorstop;
	int rotationplace = motorstop;
	SensorValue[encoderright] = basencodervalue;
	while(SensorValue[encoderright] < 150){
		motor[motorleft] = sensorturn;
		motor[motorright] = sensorturn;
		if(SensorValue[infrasenselong] > currvalue){
			currvalue = SensorValue[infrasenselong];
			rotationplace = SensorValue[encoderright];
		}
		int bumpaction = bumpercheck();
		if(bumpaction == 1){
			return scan_FAILURE;
		}
	}
	while(SensorValue[encoderright] > -150){
		motor[motorleft] = -sensorturn;
		motor[motorright] = -sensorturn;
		if(SensorValue[infrasenselong] > currvalue){
			currvalue = SensorValue[infrasenselong];
			rotationplace = SensorValue[encoderright];
		}
		int bumpaction = bumpercheck();
		if(bumpaction == 1){
			return scan_FAILURE;
		}
	}
	while(SensorValue[encoderright] < rotationplace){
		motor[motorleft] = sensorturn;
		motor[motorright] = sensorturn;
		int bumpaction = bumpercheck();
		if(bumpaction == 1){
			return scan_FAILURE;
		}
	}
	motor[motorleft] = motorstop;
	motor[motorright] = motorstop;
	SensorValue[encoderright] = basencodervalue;
	return scan_SUCCESS;
}

/* halfpanscan()
*			This is the third iteration of our search.
*			This function is an exact copy of panandscan() except the distance it turns in either direction is reduced to about a third.
*			This function is accurate within a few degrees up to 10 metres.
*			The control stays in the function for the duration of the search, so you can't do anything other than use bumpercheck() while it's looking.
*			This function ends and returns scan_FAILURE if it was interrupted by a bumpercheck() action, or scan_SUCCESS if it wasn't.
*/
int halfpanscan(){
	int currvalue = 0;
	int rotationplace = 0;
	SensorValue[encoderright] = basencodervalue;
	while(SensorValue[encoderright] < 50){
		motor[motorleft] = sensorturn;
		motor[motorright] = sensorturn;
		if(SensorValue[infrasenselong] > currvalue){
			currvalue = SensorValue[infrasenselong];
			rotationplace = SensorValue[encoderright];
		}
		int bumpaction = bumpercheck();
		if(bumpaction == 1){
			return scan_FAILURE;
		}
	}
	while(SensorValue[encoderright] > -75){
		motor[motorleft] = -sensorturn;
		motor[motorright] = -sensorturn;
		if(SensorValue[infrasenselong] > currvalue){
			currvalue = SensorValue[infrasenselong];
			rotationplace = SensorValue[encoderright];
		}
		int bumpaction = bumpercheck();
		if(bumpaction == 1){
			return scan_FAILURE;
		}
	}
	while(SensorValue[encoderright] < rotationplace){
		motor[motorleft] = sensorturn;
		motor[motorright] = sensorturn;
		int bumpaction = bumpercheck();
		if(bumpaction == 1){
			return scan_FAILURE;
		}
	}
	motor[motorleft] = motorstop;
	motor[motorright] = motorstop;
	SensorValue[encoderright] = basencodervalue;
	return scan_SUCCESS;
}

/*	armreturn()
*			This function returns the neutralization arm to its starting position.
*			The starting position is the place where the arm causes both armbutton and limittop to be pushed.
*			It starts by having both shoulder and elbow move at their shouldermove and elbowreturn rates, until either limittop or armbutton is pushed.
*			Then it moves the part of the arm that's not in position at the same speed as before until it's in position.
*			The control stays in the function for the duration of the motion, so you can't do anything while it's returning.
*/
void armreturn(){
	limit_pushed = false;
	armbutton_pushed = false;
	while(!limit_pushed && !armbutton_pushed){
		monitorInput();
		motor[shoulder] = shouldermove;
		motor[elbow] = elbowreturn;
	}
	while(!limit_pushed){
		monitorInput();
		motor[shoulder] = shouldermove;
	}
	while(!armbutton_pushed){
		monitorInput();
		motor[elbow] = elbowreturn;
	}
	motor[shoulder] = motorstop;
	motor[elbow] = motorstop;
}

/*	armdeploy()
*			This function causes the arm to extend in order to neutralize the source.
*			Until armstop is pushed, it moves elbow and shoulder at a experimentally determined rate that moves the arm's portions correctly.
*			Then, it stops.
*			The control stays in the function for the duration of the motion, so you can't do anything while it's deploying.
*/
void armdeploy(){
	armstop_pushed = false;
	while(!armstop_pushed){
		monitorInput();
		motor[elbow] = -elbowextend;
		motor[shoulder] = -shouldermove;
	}
	motor[shoulder] = motorstop;
	motor[elbow] = motorstop;
	armstop_pushed = false;
}

/*	neutralizecheck()
*			This function uses the highest of 1000 sampled SensorValue(infrasenseshort) readings and stores it in infravalue.
*			It then checks whether infravalue is higher than neutralizerange, the observed range at which our neutralization method will work.
*			If infravalue is higher than neutralizerange, then it calls armdeploy and armreturn to return the arm to its start position then neutralize.
*			It then returns neutralize_SUCCESS.
*			If infravalue is not higher than neutralizerange, it returns neutralize_FAILURE and ends.
*/
int neutralizecheck(){
	int x;
	int infravalue = 0;
	for(x=0;x<1000;x++){
		SensorValue(infrasenseshort) = 0;
		if(SensorValue[infrasenseshort]>infravalue){
			infravalue = SensorValue[infrasenseshort];
			wait1Msec(1);
		}
	}
	SensorValue(infrasenseshort) = 0;
	if(infravalue > neutralizerange){
		armreturn();
		armdeploy();
		wait10Msec(100);
		armreturn();
		return neutralize_SUCCESS;
	}
	else{
		return neutralize_FAILURE;
	}
}

/* [buttonname]action()
*			This is a family of functions that describe what happens when bumpercheck() is called and a bumper is found to be pressed.
*			When any button is pushed (by running into a wall) it moves in the direction opposite to the location of the button...
*				e.g. bumpleft, bumpright and centrefrontpush all cause a backwards move, while leftbackpush and backpush cause a forwards move
*			Then it calls fullturnscan(), panandscan() and halfpanscan() in sequence again, so it points at the source and then finishes.
*			During the backward or forward motion, bumpercheck() is not called as this leads to a recursive call...
*				thus the bumpers are disabled during the forward or backwards move.
*			The bumpers are reenabled once the scans start again.
*/
void centrefrontpushaction(){
	motor[motorleft] = motorstop;
	motor[motorright] = motorstop;
	wait10Msec(50);
	SensorValue[encoderleft] = basencodervalue;
	SensorValue[encoderright] = basencodervalue;
	while(SensorValue[encoderright] < backupdistance){
		straightcheckback();
		/*int bumpaction = bumpercheck();
		if(bumpaction == 1){
			break;
		}*/
	}
	int scansig = fullturnscan();
	if(scansig == scan_SUCCESS){
		wait10Msec(10);
		scansig = panandscan();
		if(scansig == scan_SUCCESS){
			wait10Msec(10);
			halfpanscan();
		}
	}
}

void leftbackpushaction(){
	motor[motorleft] = motorstop;
	motor[motorright] = motorstop;
	wait10Msec(50);
	SensorValue[encoderleft] = basencodervalue;
	SensorValue[encoderright] = basencodervalue;
	while(SensorValue[encoderright] > goforwardistance){
		straightcheck();
		/*int bumpaction = bumpercheck();
		if(bumpaction == 1){
			break;
		}*/
	}
	int scansig = fullturnscan();
	if(scansig == scan_SUCCESS){
		wait10Msec(10);
		scansig = panandscan();
		if(scansig == scan_SUCCESS){
			wait10Msec(10);
			halfpanscan();
		}
	}
}

void backpushaction(){
	motor[motorleft] = motorstop;
	motor[motorright] = motorstop;
	wait10Msec(50);
	SensorValue[encoderleft] = basencodervalue;
	SensorValue[encoderright] = basencodervalue;
	while(SensorValue[encoderright] > goforwardistance){
		straightcheck();
		/*int bumpaction = bumpercheck();
		if(bumpaction == 1){
			break;
		}*/
	}
	int scansig = fullturnscan();
	if(scansig == scan_SUCCESS){
		wait10Msec(10);
		scansig = panandscan();
		if(scansig == scan_SUCCESS){
			wait10Msec(10);
			halfpanscan();
		}
	}
}

void bumpleftaction(){
	motor[motorleft] = motorstop;
	motor[motorright] = motorstop;
	wait10Msec(50);
	SensorValue[encoderleft] = 0;
	SensorValue[encoderright] = 0;
	while(SensorValue[encoderright] < backupdistance){
		straightcheckback();
		/*int bumpaction = bumpercheck();
		if(bumpaction == 1){
			break;
		}*/
	}
	int scansig = fullturnscan();
	if(scansig == scan_SUCCESS){
		wait10Msec(10);
		scansig = panandscan();
		if(scansig == scan_SUCCESS){
			wait10Msec(10);
			halfpanscan();
		}
	}
}

void bumprightaction(){
	motor[motorleft] = motorstop;
	motor[motorright] = motorstop;
	wait10Msec(50);
	SensorValue[encoderleft] = 0;
	SensorValue[encoderright] = 0;
	while(SensorValue[encoderright] < backupdistance){
		straightcheckback();
		/*int bumpaction = bumpercheck();
		if(bumpaction == 1){
			break;
		}*/
	}
	int scansig = fullturnscan();
	if(scansig == scan_SUCCESS){
		wait10Msec(10);
		scansig = panandscan();
		if(scansig == scan_SUCCESS){
			wait10Msec(10);
			halfpanscan();
		}
	}
}

task main()
{
	//These statements just set the input variables to false and sets the motors to zero, so everything is reset at the beginning of the program.
	bumpleft_pushed = false;
	bumpright_pushed = false;
	limit_pushed = false;
	armbutton_pushed = false;
	armstop_pushed = false;
	motor[motorleft] = motorstop;
	motor[motorright] = motorstop;
	motor[shoulder] = motorstop;
	motor[elbow] = motorstop;
	encoderreset();
	int bumpaction = 0;
	//int neutralizesig;
	//wait10Msec(200);

	//This block of code (until the end of this if statement) checks if the front button is pushed when the robot is turned on...
	//	If so, it will neutralize, do a little motion with the elbow of the arm (to signal completion) and then end the program.
	//Otherwise, it will continue onto the rest of main().
	centrefrontpush_pushed = false;
	monitorInput();
	if(centrefrontpush_pushed){
		armreturn();
		armdeploy();
		wait10Msec(200);
		armreturn();
		motor[elbow] = elbowextend;
		wait10Msec(30);
		motor[elbow] = motorstop;
		StopAllTasks();
	}

	//This code (until the end of this if statement) calls all the scans in sequence.
	//The purpose of the if statements is to make sure that the scan sequence won't continue if the scan is interrupted by a bumpercheck() action...
	//	As each of those actions calls the full scan themselves.
	int scansig = fullturnscan();
	if(scansig == scan_SUCCESS){
		wait10Msec(10);
		scansig = panandscan();
		if(scansig == scan_SUCCESS){
			wait10Msec(10);
			halfpanscan();
		}
	}

	//This code (until the end of this while loop) causes the robot to move forward using straightcheck()...
	//until infrasenseshort sees a value higher than neutralizerange.
	//If infrasenseshort sees a value higher than neutralizerange, the robot stops in place.
	//Every half metre, panandscan and halfpanscan() are called to make sure we're pointing directly at the source.
	//There is an if statement (the second one in this block) so that we don't continue scanning if panandscan is interrupted by a bumpercheck() action.
	encoderreset();
	SensorValue(infrasenseshort) = 0;
	while((SensorValue(infrasenseshort) < neutralizerange) && (SensorValue(infrasenselong) < neutralizelongrange)){
		straightcheck();
		bumpaction = bumpercheck();
		/*if(bumpaction == 1){
			StartTask(main);
		}*/
		if(SensorValue(encoderleft) < (meterdistance / 4)){
			motor[motorleft] = motorstop;
			motor[motorright] = motorstop;
			wait10Msec(10);
			halfpanscan();
			encoderreset();
		}
	}
	motor[motorleft] = -150;
	motor[motorright] = 150;
	wait10Msec(5);
	motor[motorleft] = motorstop;
	motor[motorright] = motorstop;
	SensorValue(infrasenseshort) = 0;
	int neutralizesig = neutralizecheck();
	if(neutralizesig == neutralize_SUCCESS){
		backupturn();
		turnright90();
	}
	//if(neutralizesig == neutralize_FAILURE){
	//	StartTask(main);
	//}
		//When the right bumper is pushed, fullturnscan(), panandscan(), and halfpanscan() are called in sequence.
		//This should point the robot directly at the infrared source.
		//Then, it takes one thousand samples from the short-range sensor infrasenseshort().
		//If the highest of the samples is higher than a threshold neutralizerange, the value of which we will adjust before our trial...
		//	Then it calls armreturn() to return the arm to its home position, then calls armdeploy() to move the arm out to neutralize the source
		//	Then it waits a short time and calls armreturn() again to return the arm back to its home position.
		/*if(bumpright_pushed){
			bumpright_pushed = false;
			wait10Msec(25);
			fullturnscan();
			wait10Msec(25);
			panandscan();
			wait10Msec(25);
			halfpanscan();
			int x;
			int infravalue = 0;
			for(x=0;x<1000;x++){
				if(SensorValue[infrasenseshort]>infravalue){
					infravalue = SensorValue[infrasenseshort];
					wait1Msec(1);
				}
			}
			if(infravalue > neutralizerange){
				armreturn();
				armdeploy();
				wait10Msec(100);
				armreturn();
			}
		}*/
}
